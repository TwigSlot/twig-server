"""
Contains lower-level DB objects. These are not really types, since
we are subclassing this for things we insert into the database.
"""
import datetime
import json
from typing import Optional, Generic

from pydantic import BaseModel, validator, Field

from twig_server.models.types import VK
from twig_server.neo4j_orm_lite.orm import TwigNeoModel
from twig_server.neo4j_orm_lite.query import PreparedCypherQuery


class BaseDbObject(Generic[VK], BaseModel, TwigNeoModel):
    """
    A base object to build upon. Inherit this if you are writing
    a model that needs to be inserted into our graph database. This contains some
    trivial and uninteresting functionalities, such as:

    - maintaining the ID of the object in the database
    - recording the time that the object was created in the database
    - recording when any property (excluding the id) of this object was changed in
     the database
    """
    # Unique identifier for this resource object
    # Note: This should not be manually filled in, as it will be assigned by the db.
    id: Optional[VK] = Field(None, allow_mutation=False)

    # Time that this thing was created in the database in UTC.
    creation_time_utc: datetime.datetime = Field(
        default_factory=datetime.datetime.utcnow, allow_mutation=False
    )

    # Time that ANY property of this object was changed in the database, in UTC.
    last_modification_time_utc: datetime.datetime = Field(
        default_factory=datetime.datetime.utcnow
    )

    class Config:
        validate_assignment = True
        # we want the datetime as a unix timestamp, for easy and consistent parsing.
        json_encoders = {
            datetime: lambda dt: dt.timestamp()
        }

    def serialize_for_neo4j_insert(self):
        """
        Serializes this object for insertion into the database.
        In particular, this removes the ID field, since that is
        automatically generated by the database.

        Returns:
            A dictionary that can be inserted into the database.

        Notes:
            This is a bit hacky, since pydantic doesn't have a way to just serialize
            datetime objects when you call dict. If performance starts being
            a concern, replace this method with a manual implementation.
        """
        return json.loads(self.json(exclude={"id"}))

    def create(self) -> PreparedCypherQuery:
        """
        Creates this object in the database.

        Raises:
            If the object is already in the database (i.e. it has an ID)
        """
        if self.id:
            # TODO: change this exception type
            raise Exception(
                "Cannot create an object that is already in the database (this object "
                "has an ID)")
        pq = PreparedCypherQuery(self._create_query_str(), {
            "props": self.serialize_for_neo4j_insert()
        })
        return pq

    def update(self) -> PreparedCypherQuery:
        if not self.id:
            raise Exception(
                "Cannot update an object that is not in the database (this object has "
                "no ID)")
        # TODO: Differential update only
        pq = PreparedCypherQuery(self._update_query_str(), {
            "id": self.id,
            "props": self.serialize_for_neo4j_insert()
        })
        return pq

    def delete(self) -> PreparedCypherQuery:
        """
        Deletes this object from the database.

        Raises:
            If the object is not in the database (i.e. it has no ID)
        """
        if not self.id:
            # TODO: change this exception type
            raise Exception(
                "Cannot delete an object that is not in the database (this object has "
                "no ID)")
        pq = PreparedCypherQuery(self._delete_query_str(), {
            "id": self.id
        })
        return pq

    @classmethod
    def _convert_record(cls, record):
        """
        Converts a neo4j record into this
        """
        return cls.parse_obj({
            "id": record.id,
            **dict(record.items())
        })


class BaseTwigObject(BaseDbObject[VK]):
    """
    A base Twig Object. This is probably what you want to inherit if you are
    modelling something.

    `name` is simply the name of this object. For example, a resource could have
    "Bijection between [0, 1] and (0, 1)". A project could be named
    "Quantum Field Theory".

    `description` is well, self-explanatory. For example, a resource could have
    ""This proves that [0, 1] and (0, 1) are equinumerous" as a description. A project
    could have "Collection of my QFT notes" as a description.

    Note that the description should NOT be an empty string if provided.

    Notes:
        Implementation note: Apparently, the generic type needs to be passed through.
        https://mypy.readthedocs.io/en/stable/generics.html#defining-sub-classes-of
        -generic-classes
    """
    name: str = Field(..., min_length=1)
    description: Optional[str]

    @validator("description")
    def description_not_empty(cls, v):
        if v == "":
            raise ValueError("description should not be an empty string")
        return v

    def add_relationship(self, other: VK):
        """
        Adds a directed edge going from this object to the other object.

        Notes:
            The cypher query string for adding a relationship is:
            The `SRC_LABEL`, `DST_LABEL` and `RELATIONSHIP_LABEL` are meant
            to be customized.

            ```cypher
            MATCH (src:SRC_LABEL),
            (dst:DST_LABEL)
            WHERE id(src) = $src_id AND id(dst) = $dst_id
            CREATE (src)-[r:RELATIONSHIP_LABEL]->(dst)
            RETURN id(r)
            ```
        """
        # TODO: This will be quite useful, actually.
        raise NotImplementedError("Not done yet")
